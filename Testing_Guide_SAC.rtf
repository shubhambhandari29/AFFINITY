{\rtf1\ansi\deff0
{\fonttbl{\f0 Calibri;}}
\fs24
\b SAC Application Testing Guide (End-to-End)\b0\par
\par
This document explains what to test, why it matters, and how to do it for the SAC application. It is written for someone new to testing and gives end-to-end clarity from UI to API to database.\par
\par
\b Quick App Summary (What we are testing)\b0\par
- Frontend: React web app (browser UI).\par
- Backend: FastAPI service (Python).\par
- Database: SQL Server / Azure SQL.\par
- Key code areas: api/ (routes), services/ (business logic), core/models/ (validation schemas), core/db_helpers.py (SQL helpers).\par
\par
\b How to use this guide\b0\par
- If you are new, start with 2.1 and read in order.\par
- If you need fast coverage, focus on 2.2 (Unit), 2.3 (API), 2.4 (Integration), and 2.6 (E2E).\par
- If you are migrating data, 2.8 is critical.\par
\par
\b What does "test" mean?\b0\par
Testing means proving the app works correctly, handles errors safely, and matches business expectations. It is not just about finding bugs. It is also about building confidence for releases.\par
\par
\b 2.1 Functional Testing (Core)\b0\par
\b What it means\b0\par
Functional testing validates that features and workflows behave as expected from the user and business perspective.\par
\par
\b What to test in our app\b0\par
- Authentication: login, logout, session timeouts, and role access.\par
- SAC modules: accounts, policies, affiliates, account associations.\par
- Distribution and frequency flows: claim review, loss run, deduct bill.\par
- Dropdowns and lookup data (example: services/dropdowns_service.py).\par
- Validations and error handling: required fields, invalid formats, missing data.\par
\par
\b Hidden legacy behavior to confirm\b0\par
- Default values that were auto-filled in VB forms.\par
- Calculations triggered when fields change.\par
- Implicit validation rules (ex: trimming strings, auto-uppercase).\par
\par
\b What to document\b0\par
- Feature list with expected behavior.\par
- All validations (field rules and error messages).\par
- Known legacy behavior that must be preserved.\par
- Dependencies between screens or fields.\par
\par
\b Example scenario\b0\par
"When a user selects a Service Level from a dropdown, related fields auto-populate and saving requires Service Level to be valid."\par
\par
\b 2.2 Unit Testing (React + FastAPI)\b0\par
\b What it means\b0\par
Unit testing checks small pieces of code in isolation so we can catch bugs early and cheaply.\par
\par
\b FastAPI unit tests (backend)\b0\par
What to test:\par
- Service functions in services/ and services/sac/.\par
- Business rules and calculations (e.g., distribution percentages, totals).\par
- Validation logic and DTO mapping in core/models/.\par
- Error handling for missing/invalid inputs.\par
How to test:\par
- Mock database calls using core/db_helpers.py so tests are fast and do not need a real DB.\par
- Use pytest to verify inputs and outputs of each function.\par
\par
\b React unit tests (frontend)\b0\par
What to test:\par
- Component rendering and conditional UI states.\par
- Form validation rules (client-side).\par
- API error handling and messaging.\par
How to test:\par
- Use React Testing Library to render components and simulate user actions.\par
\par
\b What to document\b0\par
- Where tests live (for example: tests/services/, tests/core/).\par
- Mocking strategy (what is mocked and why).\par
- Minimum coverage goals for critical services.\par
\par
\b 2.3 API Testing (FastAPI Layer)\b0\par
\b What it means\b0\par
API tests validate that endpoints behave correctly for request/response, status codes, and security.\par
\par
\b What to test in our app\b0\par
- Endpoints in api/sac/ and api/dropdowns.py.\par
- Authentication and authorization rules in api/auth.py and services/auth_service.py.\par
- Request schema validation in core/models/.\par
- Pagination, filtering, sorting, and error messages.\par
\par
\b How to test\b0\par
- Use FastAPI TestClient.\par
- Use test users with different roles.\par
- Validate response JSON shape and status codes.\par
\par
\b What to document\b0\par
- Required headers and authentication type (JWT/cookie).\par
- Request/response examples for each endpoint.\par
- Error response format (message, code).\par
\par
\b 2.4 Integration Testing (Service <-> Azure SQL)\b0\par
\b What it means\b0\par
Integration testing validates that the backend works correctly with the real database.\par
\par
\b What to test in our app\b0\par
- SQL query correctness produced by core/db_helpers.py.\par
- Transaction integrity (commit/rollback).\par
- Stored procedures or functions if used.\par
- Connection pooling and timeout handling.\par
\par
\b How to test\b0\par
- Run tests against a dedicated test database.\par
- Seed known data, run tests, then clean up.\par
\par
\b What to document\b0\par
- Test database connection info (not secrets).\par
- Data seed scripts and cleanup strategy.\par
- DB assumptions: collation, compatibility level, indexes.\par
\par
\b 2.5 UI Testing (React)\b0\par
\b What it means\b0\par
UI tests validate that the actual browser UI works as expected.\par
\par
\b What to test in our app\b0\par
- Login and session flows.\par
- Routing between pages.\par
- Form validation (client + server errors).\par
- File download/upload flows.\par
\par
\b How to test\b0\par
- Use Playwright or Cypress for automated UI tests.\par
- Focus on major workflows, not every single input field.\par
\par
\b What to document\b0\par
- UI smoke suite list (login, search, create/update).\par
- Browser support (Chrome, Edge).\par
- Required test data and setup steps.\par
\par
\b 2.6 End-to-End (E2E) Testing\b0\par
\b What it means\b0\par
E2E tests run the full flow: UI -> API -> DB, just like a real user.\par
\par
\b What to test in our app\b0\par
- Happy paths for core workflows (e.g., search account, view policy, update distribution).\par
- Key negative flows (permission denied, validation failures).\par
- Smoke tests after every release.\par
\par
\b How to test\b0\par
- Use a stable test environment.\par
- Use test users with known permissions.\par
\par
\b What to document\b0\par
- E2E scenario list.\par
- Expected outcomes and screenshots (if needed).\par
- How to reset the test data between runs.\par
\par
\b 2.7 Regression Testing\b0\par
\b What it means\b0\par
Regression testing ensures new changes do not break existing functionality.\par
\par
\b What to test in our app\b0\par
- Core business capabilities (accounts, policies, distributions).\par
- Auth, dropdowns, and critical reports.\par
\par
\b How to test\b0\par
- Maintain a regression checklist.\par
- Automate the most critical flows first.\par
\par
\b What to document\b0\par
- Regression suite and release checklist.\par
- Who runs it and when (per release or per sprint).\par
\par
\b 2.8 Data Migration Testing (Most Important in Migration Projects)\b0\par
\b What it means\b0\par
Data migration testing proves that data moved to Azure SQL is complete and correct.\par
\par
\b What to test in our app\b0\par
- Schema checks: tables, columns, types, constraints.\par
- Row counts per table and per key range.\par
- Critical data sampling (accounts, policies, distributions).\par
- Foreign keys and orphan record checks.\par
- Aggregate totals and report reconciliation.\par
\par
\b How to test\b0\par
- Use scripts to compare old and new DB snapshots.\par
- Define tolerance rules (exact match for critical data).\par
\par
\b What to document\b0\par
- Reconciliation rules and acceptance criteria.\par
- Cutover plan and rollback steps.\par
- Migration validation scripts.\par
\par
\b 2.9 Performance and Load Testing\b0\par
\b What it means\b0\par
Performance testing ensures the app is fast and stable under real-world load.\par
\par
\b What to test in our app\b0\par
- API response time for search and report endpoints.\par
- Concurrent users performing heavy search/filter operations.\par
- DB query performance and slow query detection.\par
\par
\b How to test\b0\par
- Use tools like Locust or k6 for API load tests.\par
- Record baseline response times and compare after changes.\par
\par
\b What to document\b0\par
- Performance targets per endpoint (SLA).\par
- Load profiles (peak hour usage).\par
- Test results and tuning changes.\par
\par
\b 2.10 Security Testing\b0\par
\b What it means\b0\par
Security testing protects user data and prevents unauthorized access.\par
\par
\b What to test in our app\b0\par
- Authentication flow and token/cookie safety.\par
- Role-based access to endpoints.\par
- Input validation to prevent SQL injection.\par
- Secrets and config handling.\par
- Audit logging (who did what, when).\par
\par
\b How to test\b0\par
- Attempt unauthorized access to protected endpoints.\par
- Use automated scanners for dependencies.\par
- Test OWASP API Top 10 patterns.\par
\par
\b What to document\b0\par
- Security requirements and sensitive endpoints.\par
- Audit log expectations.\par
- Dependency scanning process.\par
\par
\b Example End-to-End Flow (Simple Walkthrough)\b0\par
1) Login with a test user.\par
2) Search for an account (services/sac/search_sac_account_service.py).\par
3) Open account details and view policies (services/sac/sac_policies_service.py).\par
4) Update a distribution (services/sac/claim_review_distribution_service.py or services/sac/deduct_bill_distribution_service.py).\par
5) Verify the database record changed correctly.\par
6) Logout and confirm session is closed.\par
\par
\b Final Notes\b0\par
- Start small: write tests for the most critical flows first.\par
- Keep tests readable and focused on behavior.\par
- Add to this document as new features are added.\par
\par
}
